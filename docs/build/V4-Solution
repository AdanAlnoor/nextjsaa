# V4 Solution: Resolving Next.js Hydration and Webpack Errors

This document provides a comprehensive analysis and solution for the critical hydration and Webpack errors occurring in the Next.js application.

## 1. Summary of the Problem

The application is consistently failing with two primary errors in the browser console:

1.  **React Hydration Error:** `Warning: An error occurred during hydration. The server HTML was replaced with client content in <#document>.`
2.  **Webpack Module Error:** `Uncaught TypeError: Cannot read properties of undefined (reading 'call') at options.factory...`

These errors indicate a fundamental mismatch between the HTML generated by the server and the application state expected by the client, caused by a failure to load a JavaScript module during Server-Side Rendering (SSR).

## 2. Root Cause Analysis

The root cause is the **widespread static import of a client-side-only library (`@supabase/ssr`'s `createBrowserClient`) into Server Components**.

Our investigation, confirmed by a project-wide search, revealed over 50 files incorrectly importing the client-side Supabase helper like this:

```typescript
// Found in pages, components, services, and layouts
import { createClient } from '@/shared/lib/supabase/client';
```

When Next.js attempts to render a page on the server, it evaluates these imports. Since `createClient` from `@/shared/lib/supabase/client` is designed to run in a browser environment (where `window` exists), it fails to initialize correctly in the Node.js environment on the server. This failure prevents Webpack from building the module, leading to the `(reading 'call')` error and subsequently causing the server to generate incomplete HTML, which triggers the hydration error on the client.

While key files like `page.tsx` and `auth-provider.tsx` were updated to use dynamic imports, the issue persists because the static import pattern is deeply integrated throughout the rest of the codebase.

## 3. The Comprehensive Solution

The solution requires a two-part architectural change to correctly handle client-side and server-side code execution.

### Part A: Convert to Dynamic Imports in Client Components

For any component that runs on the client (marked with `'use client'`), you must replace static imports of the Supabase client with dynamic `import()` calls inside `useEffect` hooks or event handlers.

**This is the immediate fix for client-side interactions.**

**Example Refactor in a Client Component:**

```typescript
// BEFORE: This causes the SSR error
'use client';
import { createClient } from '@/shared/lib/supabase/client';

function SomeClientComponent() {
  const supabase = createClient();
  // ... logic using supabase
}
```

```typescript
// AFTER: This is SSR-safe
'use client';
import { useEffect, useState } from 'react';
import type { SupabaseClient } from '@supabase/supabase-js';

function SomeClientComponent() {
  const [supabase, setSupabase] = useState<SupabaseClient | null>(null);

  useEffect(() => {
    const initSupabase = async () => {
      const { createClient } = await import('@/shared/lib/supabase/client');
      setSupabase(createClient());
    };
    initSupabase();
  }, []);

  // ... logic can now safely use the supabase instance once it's not null
}
```

### Part B: Implement a Server-Side Supabase Client

For fetching data in Server Components (RSCs) like pages and layouts, you must **stop using the browser client**. The correct approach is to create and use a dedicated server-side client that can securely access cookies and perform data fetching during the server render.

**Step 1: Create the Server Client Helper**

Create a new file at `src/shared/lib/supabase/server.ts`:

```typescript
// src/shared/lib/supabase/server.ts
import { createServerClient, type CookieOptions } from '@supabase/ssr'
import { cookies } from 'next/headers'
import type { Database } from '@/shared/types/supabase';

export function createSupabaseServerClient() {
  const cookieStore = cookies()

  return createServerClient<Database>(
    process.env.NEXT_PUBLIC_SUPABASE_URL!,
    process.env.NEXT_PUBLIC_SUPABASE_ANON_KEY!,
    {
      cookies: {
        get(name: string) {
          return cookieStore.get(name)?.value
        },
        set(name: string, value: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value, ...options })
          } catch (error) {
            // The `set` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
        remove(name: string, options: CookieOptions) {
          try {
            cookieStore.set({ name, value: '', ...options })
          } catch (error) {
            // The `delete` method was called from a Server Component.
            // This can be ignored if you have middleware refreshing
            // user sessions.
          }
        },
      },
    }
  )
}
```

**Step 2: Use the Server Client in Server Components**

Now, you can use this new server client to fetch data directly in your Server Components.

**Example Refactor in a Page (`app/projects/page.tsx`):**

```typescript
// BEFORE: Uses the wrong client
import { createClient } from '@/shared/lib/supabase/client'; // WRONG
// ... logic attempts to fetch data on the server with a client client

```

```typescript
// AFTER: Uses the correct server client
import { createSupabaseServerClient } from '@/shared/lib/supabase/server';
import ProjectList from '@/features/projects/components/projects/project-list'; // Example client component

// This is now a true Server Component that fetches data
export default async function ProjectsPage() {
  const supabase = createSupabaseServerClient();
  const { data: projects, error } = await supabase.from('projects').select('*');

  if (error) {
    // Handle error appropriately
    return <p>Error loading projects.</p>;
  }

  // Pass the server-fetched data as props to a Client Component for display
  return <ProjectList projects={projects} />;
}
```

### Part C: Recommended Refactoring Plan

Given the large number of affected files, a systematic approach is necessary:

1.  **Create the Server Client:** Implement the `createSupabaseServerClient` helper as described in Part B.
2.  **Fix High-Impact Pages:** Start by refactoring `app/projects/page.tsx`, `app/admin/layout.tsx`, and other key pages/layouts to use the new server client for data fetching. This will unblock the main parts of your application.
3.  **Refactor Shared Client Components:** Go through shared components identified in the search, such as `UserNav.tsx` and `RoleGuard.tsx`, and convert them to use dynamic imports as shown in Part A.
4.  **Systematically Update Remaining Files:** Work through the rest of the files from the `grep` search results, applying either the dynamic import pattern (for client components) or switching to the server client (for server-side data logic).
5.  **Clean up Scripts:** Update any scripts in `src/scripts` to use the standard `createClient` from `@supabase/supabase-js` and to be configured with a service role key if they are run in a non-browser environment.

## 4. How to Verify the Fix

After implementing the changes:

1.  **Clear the Cache:** Delete the `.next` folder in your project root to ensure no old code is being used.
2.  **Restart the Server:** Stop the development server if it's running and restart it with `npm run dev`.

The application should now load without any hydration warnings or Webpack `(reading 'call')` errors in the console.
